---
const { eyebrowText, title } = Astro.props;

// Split the title into words safely
const words = title ? title.trim().split(" ") : [];
const lastWord = words.pop();
const firstPart = words.join(" ");
---

<div class="relative inline-block">
  {
    eyebrowText && (
      <p class="text-n-600 mb-2.5 text-sm font-light md:mb-1 md:text-xl">
        {eyebrowText}
      </p>
    )
  }

  <p
    id="animatedText"
    class="animatedText text-n-800 flex flex-wrap gap-0 text-4xl/11 font-medium md:text-6xl/20 md:leading-[73px] 2xl:text-7xl/24"
  >
    {
      firstPart
        .split(" ")
        .map((word: string) => (
          <span class="inline-block opacity-0">{word}&nbsp;</span>
        ))
    }
    <span class="relative inline-block">
      <span class="inline-block opacity-0">{lastWord}</span>
      <svg
        class="absolute -right-[20px] -bottom-[15px] -z-1 h-[19px] w-[130px] md:right-0 md:h-[34px] md:w-[232px] lg:-bottom-[30px] xl:h-[47px] xl:w-[300px]"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 353 48"
        fill="none"
      >
        <path
          d="M2.65652 37.4603C45.9947 21.9917 176.227 -18.7211 349.157 10.0033C351.336 10.3653 352.809 12.4257 352.448 14.6049C352.086 16.7841 350.025 18.2578 347.846 17.8959C176.775 -10.5199 48.0079 29.7673 5.34598 44.9945C3.2654 45.7371 0.976289 44.6523 0.233671 42.5717C-0.508594 40.4913 0.576181 38.2029 2.65652 37.4603Z"
          fill="#CC554D"></path>
        <path
          d="M78.627 39.415C111.297 27.4685 218.007 8.01076 330.684 27.5283C332.86 27.9053 334.319 29.9757 333.942 32.1523C333.565 34.329 331.495 35.7881 329.318 35.4111C217.996 16.1281 112.706 35.4711 81.375 46.9277C79.3002 47.6864 77.0028 46.6197 76.2441 44.5449C75.4857 42.4703 76.5525 40.1738 78.627 39.415Z"
          fill="#CC554D"></path>
      </svg>
    </span>
  </p>
</div>

<script>
  import { animate, stagger } from "motion";

  // Select all containers
  const containers = Array.from(document.querySelectorAll(".animatedText"));
  console.log(containers);

  const once = new WeakSet();

  const io = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting && !once.has(entry.target)) {
          once.add(entry.target);

          // Animate spans inside the currently observed container
          const spans = entry.target.querySelectorAll("span");

          animate(
            spans,
            { opacity: [0, 1], y: [20, 0] },
            { duration: 0.6, delay: stagger(0.08), easing: "ease-out" },
          );
        }
      });
    },
    { threshold: 0.3 }, // trigger when ~30% visible
  );

  containers.forEach((el) => io.observe(el));
</script>
